### Catering Manager, 2004—present

Private repo; please contact me for access

**Stack: Ruby on Rails 5.2, Javascript, jQuery, HTML5, CSS3, AWS, Digital Ocean,
Docker, PostgreSQL, Ubuntu Server**

Catering Manager is a real-world application, in production use today, used by
Orlando's catering and La Perla Ballroom, which generates customer-facing quotes
(in .pdf format), books and tracks events, and is used by staff for organizing
events.

### [Bufala Online Order & Pickup](https://github.com/SunnieBB/hungry-people), October 2019

**Stack: Node, Express, EJS, HTML, CSS, Javascript, jQuery, PostgreSQL, Twilio
API**

Bufala is a real restaurant for which my team and I built a fictitious online
order-and-pickup system for our mid-term project at Lighthouse Labs. We wanted
to build a magazine-spread-like web site that is both appealing and easy to
use. The app—which includes both a front-of-house module for customer orders,
and a back-of-house module for order-prep at the restaurant—makes extensive use
of SMS messages to keep the customer informed about their order after leaving
the website.

### BarChart, September 2019

https://github.com/fapapa/bar-chart-js

**Stack: HTML, CSS, Javascript, jQuery**

BarChart is a Javascript library that allows you to generate bar charts for
display on websites. This was an optional *stretch project* for my pre-course
prep work for Lighthouse Labs. Out of the many hundreds of students who have
taken the course, only a handful have completed or even attempted this project.

### TinyApp, September 2019

https://github.com/fapapa/tinyApp

**Stack: HTML, CSS, Javascript, Node, Express, EJS**

TinyApp is a clone of a URL shortening service, built as part of the Lighthouse
Labs Web Development course. I added extra features that were not part of the
standard course work, allowing a user to track their shortened URLS and access
basic analytics.

### Tweeter, October 2019

https://github.com/fapapa/tweeter

**Stack: HTML, CSS, Javascript, jQuery, Node, Express, EJS, SASS**

Tweeter is a clone of the popular social media juggernaut, completed as part of the Lighthouse Labs course work. Created as a *single-page application*, it makes extensive use of AJAX calls to keep the app feeling light and fast. I also took this opportunity to flex my flex-box muscle, and use some more advanced features of SASS; neither of which were part of the standard curriculum.

[comment]: # (### BootcampX)

### Scheduler, November 2019

https://github.com/fapapa/scheduler

**Stack: Node, Express, PostgreSQL, React, Jest, Cypress**

Scheduler is a *single-page application* built with React. It allows a user to manage interviews on a schedule, and showcases the use of React best practices, such as pure functions, hooks and custom hooks, and reducers. I also implemented a set of features that use web-sockets to update one user's view when another user modifies the schedule.

[comment]: # (### LightBnB)
[comment]: # (### Snake client)
[comment]: # (### JSON the cat)
[comment]: # (### Page Fetcher)

### ISS Spotter, October 2019

https://github.com/fapapa/iss_spotter

**Stack: Node, Express, API's (IPify, IPVigilante, OpenNotify)**

This Lighthouse Labs project chains together three API's to get the user's IP address, turn that into a geolocation, and display the next flyover dates and times of the *International Space Station*. It was a great way to explore promises (and the async nature of Javascript) without using async/await.

### File Server, October 2019

https://github.com/fapapa/file-server

**Stack: Node, net library, fs library**

A Lighthouse Labs **stretch** project (to be attempted only by more advanced students in free time) to build a rudimentary file server and client. The goal was to learn about networking without the abstractions that HTTP and the various libraries and frameworks used to build modern web apps use. It made networking feel much less like voodoo, and gave me tools and confidence in general to *look under the hood* at underlying technologies.

[comment]: # (### Ceasar Cypher)
[comment]: # (### Patchworker)
[comment]: # (### Typewriter)

### GitLab - merge request !29718, June 2019

https://gitlab.com/gitlab-org/gitlab-ce/merge_requests/29718

**Stack: Ruby on Rails, PostgreSQL**

GitLab is an open-source dev-ops toolchain for developers, with tens-of-thousands of lines of code. In this contribution I added a requested feature that adds a preference to allow maintainers to create subgroups, instead of having to ask the owner of the group to create the subgroup, giving developers the option to be more agile. This contribution garnered me the title of *MVP of the release*, and a $150 gift certificate!

### GitLab - merge request !25942, March 2019

https://gitlab.com/gitlab-org/gitlab-ce/merge_requests/25942

**Stack: Ruby on Rails, PostgreSQL**

My first contribution to GitLab! Simply a matter of deleting some unnecessary lines and updating the unit tests. I wanted to get a flavour for installing GDK and stepping through the workflow of squashing bugs and adding features, while lowering Gitlab's technical debt.

### GitLab - merge request !29511, June 2019

https://gitlab.com/gitlab-org/gitlab-ce/merge_requests/29511

**Stack: Ruby on Rails, PostgreSQL**

I fixed an issue where, when pushing a repository to a new and default branch, the commit messages would not get processed for issue references, which was stopping some users of competitive products from switching to GitLab. I picked this issue to help me learn about the overall architecture of GitLab and because it was an interesting business problem.

### Assembler, March 2019

https://gitlab.com/fapapa/nand2tetris-course/tree/master/projects/06

**Stack: Ruby**

In this project for the *Build a Modern Computer from First Principles: From Nand to Tetris* course, I write an assembler, which takes a given program in Hack assembly, and converts it to Hack machine code. Machine code is the combination of raw binary bits that a processor can take as instructions for a program. It is exceptionally tedious to read or write a program in machine code, as you must encode and decode 0's and 1's exactly where they need to go to execute the instruction you want. Assembly has a one-to-one correlation to machine code (each line of assembly is one instruction), but it is symbolic and therefore much easier to read and write for us mere mortals. However, the computer needs instructions sent to it in machine code, so the assembler does the work of converting assembly language to machine code.

### VM Translator, March 2019

https://gitlab.com/fapapa/nand2tetris-course/tree/master/projects/08

**Stack: Ruby**

A VM Translator is a program that translates programs written in a VM language into programs written in an assembly language. VM languages provide a level of abstraction above assembly languages. So, whereas assembly languages are a symbolic representation of the instructions being sent to the CPU, VM languages allow the programmer to think more abstractly; usually (and in this case), that abstraction is a stack machine. The commands allow the programmer to push data onto and pop data off of a virtual stack, instead of having to deal with memory directly. This level of abstraction is still not feasible for most applications to write large programs in. So why have the VM layer at all? VMs afford a level of flexibility that would otherwise not be possible. As an example, JRuby and Java can both be compiled into JVM, which can in turn be tranlated to work on multiple different architectures/CPUs. Instead of needing one compiler per language per architecture, you need only one compiler per
language, and then one VM translator per architecture. So if there are 10 languages and five architechtures, without a VM intermediary you would need 50 compilers (5 ⨉ 10); with a VM language you would need only 10 compilers and five VM translators (5 + 10).

### Compiler, April 2019

https://gitlab.com/fapapa/nand2tetris-course/tree/master/projects/11

**Stack: Ruby**

A compiler takes some code in a high-level language and converts it into code in a lower-level language. In this case, it converts code in Jack to code in the VM language discussed above. This process is broken down into two broad steps: *syntax analysis* and *code generation*. Syntax analysis involves turning the high-level code into a stream of tokens and parsing that stream into a tree structure using the grammatical rules defined by the high-level language. Code generation uses the semantic meaning derived from the syntax analysis and generates code with the same meaning, but in the lower-level language.

### JackDoku, March 2019

https://gitlab.com/fapapa/nand2tetris-course/tree/master/projects/09/JackDoku

**Stack: Jack (a Java-like programming language created for the Nand to Tetris
Course)**

In the *Nand to Tetris* course, we build a computer from the bottom up, from a
simple NAND gate, to a computer architechture, to machine code, a virtual
machine, a programming language, an operating system, and the culmination is an
object-oriented application of our choosing. For this project I chose to build a
simple Sudoku game. The code is anything but simple though. While the OS does
provide some libraries for manipulating the screen, the libraries limit you to
writing 16⨉16 pixel sprites at pre-determined locations on the
screen. Using this library would have meant using just a little over half the
height of the screen; the game would have looked small and awkward. In order to
make my sudoku grid take up as much of the screen as possible, I had to engineer
a way to write an arbitrarily-sized sprite starting at any given pixel on the
screen. This was a challenging task, but it was gratifying to not only figure
out the details of the solution, but to also wrap those details in a layer of
abstraction that made it easy to use in my game.
